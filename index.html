<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="simple.css">
        <title>Mark's Bad Tech Advice</title>
    </head>

    <header>
        <nav>
  
            <a href="/" >Home</a>
            
            <a href="#flippycube">FlippyCube</a>
            
          </nav>
        <h1>Mark's Bad Tech Advice</h1>
        <p>Proceed at your own risk!</p>
    </header>


    <main>
		<section id="flippycube">
			<header>
				<h1>Flippy Cube</h1>
			</header>
            <p>The Flippy Cube concept was designed for the exploration of how physical manipulation and orientation of a cube could be used to control the properties of a surface on the cube which emits light. Flippy Cube's interactions are powered by an Arduino Pro Micro which uses tilt sensors and a gyroscope to detect orientation and rotation.</p>

            <dt>Jump to:</dt>
            <dd><a href="#flippycube-video">Flippy Cube Video</a></dd>
            <dd><a href="#flippycube-code">Link to GitHub Arduino Code</a></dd>
            <dd><a href="#flippycube-circuit">Circuit Schematic</a></dd>
            <dd><a href="#flippycube-story">The Flippy Cube Story</a></dd>
            <dd><a href="#flippycube-resources">References and Resources</a></dd>
        
            <section id="flippycube-video"><h4>Video</h4>
        <div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/1010268408?h=d84ed9d79a&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="fullscreen; picture-in-picture; clipboard-write" style="position:absolute;top:0;left:0;width:100%;height:100%;" title="FlippyCube - CPSC601 Assignment 0"></iframe></div><script src="https://player.vimeo.com/api/player.js"></script></section>
        
        <section id="flippycube-code"><h4>Arduino Code</h4><a href="https://github.com/MarkErik/flippy-cube">https://github.com/MarkErik/flippy-cube</a></section>
    
        <section id="flippycube-circuit"> <h4>Circuit Schematic</h4>
        <figure><img src="assets/A0Circuit.png" alt="Circuit Schematic"></figure></section>

        <section id="flippycube-story"><h4>The Story</h4>

        <h5>Flippy Cube almost didn't happen.</h5>

            <p>The initial idea was something I'll call Fally Tower. A simple tall lamp that would be lit when upright, and turn off when it fell over.</p>

            <figure><img src="assets/how-it-began.jpeg" alt="Fally Tower Sketch"></figure>

            <p>Fortunately, Prof. Oehlberg challenged me to consider how the physical characteristics of the artifact communicate or encourage interaction. The idea was then to have a series of blocks stacked on top of each other, as the motivation was a design that would encourage knocking something over so that when it fell over would turn the light off.</p>

            <h5>The birth of Flippy Cube</h5>

            <p>To start prototyping the concept, I took a box, put some green tape over one end to signify the light, and immediately I began wondering, what would happen if I rotated it? What would happen if the light wasn't facing up, or down, but instead on its side?</p>

            <p>That brought me to my first mini technical challenge - a tilt sensor can very easily signal if something is upright, or facing down. But if the box is placed on its side  (with the tilt sensor mounted straight up and down), the ball inside the tilt sensor would just be rolling around, and giving erroneous values.</p>

            <figure><img src="assets/flippy-v0.jpeg" alt="The initial Flippy Cube"></figure>

            <p>To overcome this, I decided to place the tilt sensor at a 45-degree angle, so that only when the box was turned fully upside down, the ball would roll away from the contact pins. But this presented another problem - I then wanted explore what would happen if I rolled the box while it was on its side, however, the angled tilt sensor would only work in one orientation - because if you were to roll the box while it was on its side, because of the angle of the tilt sensor, there would be times when the ball would roll away and break contact. To address this, I attached another tilt sensor, on the opposite side of the box, angled 45-degrees, but in the opposite direction, so that when the box is rolled onto that side, the tilt sensor would still be facing up. This would allow me to use logic in the code to look for when the tilt sensors on opposite sides have one sensor which is LOW and the other HIGH.
            </p>

            <h5>Adding the rotation and frying my first sensor</h5>

            <p>TLDR; My fault for not paying closer attention to the positive and negative rails on the breaboard - assuming that the positive rail is on the outside on both sides of the breadboard.</p>

            <p>To detect rotation, I used a commonly available, low-cost sensor, the MPU6050, which provides gyroscope, acceleration, and temperature sensing. It also needs 3.3V instead of 5V which I had been using for all the other components. The breadboard power supply that I used has the ability to select the voltage that it feeds the rails. I had been using the 5V rail the entire time, where the positive side is on the outside. I turned on the 3.3V supply, but didn't notice that the positive side is on the inside rail. I hooked everything up from muscle memory, red wires on the outside rail, black wires for ground on the inside rail. I powered up the Arduino, ran the sample MPU6050 code...and nothing happened.</p>
                <p>This must be a problem with code I was thinking. So I was re-checking the code, the libraries, etc. All the while, the poor little MPU6050 was being powered wrong - and getting quite warm (after I realised the wiring problem) - but "fortunately" no magic smoke. After I confirmed the code looked good, I then checked the wiring, and found my mistake, fixed the power wiring, and turned everything back on, and the power LED to the MPU6050 board turned on. Now, I wrote fortunately in quotes, because had I known that I really cooked the MPU6050 then, I could have saved myself 5 hours of trying to figure out why it wasn't working. After trying multiple libraries - turns out lots of people have made Arduino libraries to interface with MPU6050 sensors - I used the I2C scanner (linked in the Resources section below) - and found out that the MPU6050 was showing up on the bus at address 0x77. So I figured all was good still with the sensor, the power was on, and it was detected on the I2C bus. How wrong I was.</p>
                <p>After much more testing and searching, it turns out that the MPU6050 *really really* should ever only use the address of 0x68 or 0x69 - and that is what all the libraries are looking to talk to it at. Anything else means either the chip is damaged (likely what I did), or faulty, as there are lots of knock-off chips floating around.</p>

            <p>So how did I move forward? I had another gyro sensor, based on the MPU6500 (which has much less support and libraries available), which I wired up (correctly), started the Arduino, and yes! got communication and gyro readings. Unfortunately, the readings were not very easy to parse into detecting rotational movement. At that point I figured rotation detection would be a stretch goal.</p>

            <h5>At the Electrical Maker Space and a new MPU6050</h5>

            <p>The following day, I had planned to start building the final prototype, using the wires and tools at the Electrical Maker Space on campus. As I was gathering my materials, I found out that they also had a bag full of MPU6050 boards!</p>

            <p>I quickly wired one up, ran the MPU6050_light library, and not only did it work, the gyro readings were exactly what I would want to interpret rotation!</p>
            <figure>
                <img src="assets/cleaning-up.jpeg" alt="MPU6050">
                <figcaption>The working MPU6050 (little board in the middle) neatly wired in</figcaption>
            </figure>

            <figcaption>I'll skip the part where as I was leaving the Maker Space (on the Friday evening) I dropped the breadboard, broke the battery-powered breadboard supply, felt very sad, then rushed to Solarbotics to get a spare (but without a rechargeable battery), while hoping that the replacement rechargeable power supply I just ordered would arrive in time on Sunday to put everything together. (it did - phew!)</figcaption>

            <h5>Putting it all together</h5>

            <p>To increase and even-out the light output from the LED strip that I was using, I created a short compartment at the top of the cube that I lined with aluminum foil (shiny side up).</p>

            <figure>
                <img src="assets/light-reflector.jpeg" alt="Light Reflector">
            </figure>






            <h5>Post script: Everything out of cardboard</h5>
            <figure>
                <img src="assets/building-cubes.jpeg" alt="Cardboard Cubes">
                <figcaption>Building the cubes</figcaption>
            </figure>
            <figure>
                <img src="assets/tripod.JPG" alt="Cardboard Tripod">
                <figcaption>Even the tripod! (with a helping hand from the Flippy prototype)</figcaption>
            </figure>


        </section>

        <section id="flippycube-resources"><h4>References and Resources</h4>

        <p>Throughout the course of developing Flippy Cube, these were some of the key resources I used:</p>

        <h5>Arduino I2C Interface</h5>
        <p>Connecting the MPU6050 gyro sensor uses the I2C (Inter-Integrated Circuit) bus (Serial Data - SDA, and Serial Clock - SCL) on the Arduino. There is a great resource about how the bus works on Arduinos as well as I2C scanner code at: <a href="https://gammon.com.au/i2c">https://gammon.com.au/i2c</a></p>

        <h5>MPU6050 Gyroscope and Accelerometer</h5>
        <p>The MPU6050 sesnor that came from my SunFounder Arduino kit suggested that I use the Adafruit sensor libraries: <a href="https://learn.adafruit.com/mpu6050-6-dof-accelerometer-and-gyro/arduino">Adafruit - MPU6050 6-DoF Accelerometer and Gyro</a>, which also had sample code and connection diagrams at the SunFounder website: <a href="https://docs.sunfounder.com/projects/elite-explorer-kit/en/latest/basic_projects/09_basic_gy87_mpu6050.html#basic-gy87-mpu6050">MPU6050 (Basic Project)</a>. Ultimately, after much trouble-shooting, I found the MPU6050_light library easier and more reliable to work with: <a href="https://github.com/rfetick/MPU6050_light">https://github.com/rfetick/MPU6050_light</a>.</p>
    </section>




        </section>
    </main>

    <footer>
        <p>Created by Mark Altosaar, 2024</p>
        <p>Using the Simple.css layout <a href="https://github.com/kevquirk/simple.css">https://github.com/kevquirk/simple.css</a></p>
        <p>And the awesome Departure Mono font <a href="https://departuremono.com">https://departuremono.com</a></p>
    </footer>


</html>

